[
  {
    "title": "Differences between let, const, and var in JavaScript:",
    "content": "1.let:-\nUse:** For variables that can change later (but only within a block of code).**\nScope: **Block-scoped (only works inside the {} where it’s declared).**\nRedeclaration**: Cannot be redeclared in the same scope.**\n\n\n\n[code-snippet-1]\n\n2. const:-\nUse: For variables that should not change.\nScope: Block-scoped, like let.\nRedeclaration:** Cannot be redeclared or reassigned**.\nNote:** If you use const with objects or arrays, you can still modify their contents (but not reassign the whole object/array).**\n\n[code-snippet-2]\n\n\n3. var:-\nUse: The old way to declare variables (not recommended in modern code).\nScope:** Function-scoped (does not respect block-scoping).**\nRedeclaration: **Can be redeclared in the same scope (which can lead to bugs).**\n\n\n[code-snippet-3]\n",
    "codeSnippets": [
      "let age = 25;  \nage = 26; // Works!  \nconsole.log(age); // Output: 26\n\n// Redeclaration\n\n{\n let age = 25;  \nage = 26;\nlet age = 28;\n\nconsole.log(age); //Not work\n}",
      "let age = 25;  \nage = 26; // Works!  \nconsole.log(age); // Output: 26\n\n{\nlet age = 25;  \nage = 26; \nlet age= 28 // Not work\n \nconsole.log(age); \n\n}",
      "const name = \"Alice\";  \n// name = \"Bob\"; // Error! You cannot reassign a `const`.  \nconsole.log(name); // Output: Alice  \n\nconst fruits = [\"apple\", \"banana\"];\nfruits.push(\"orange\"); // Works! You can modify the array.  \nconsole.log(fruits); // Output: [\"apple\", \"banana\", \"orange\"]\n",
      "var color = \"red\";  \nvar color = \"blue\"; // Works (but can cause confusion)!  \nconsole.log(color); // Output: blue  \n\nif (true) {  \n  var test = \"inside\";  \n}  \nconsole.log(test); // Output: inside (ignores block scope)\n"
    ],
    "category": "JavaScript Basics",
    "topic": "Variables & Data Types",
    "createdAt": "2025-01-01T08:55:03.924Z",
    "id": 1735656205945,
    "lastEdited": "2025-01-01T08:55:03.936Z"
  },
  {
    "title": "How Scoping Differs Between let, const, and var",
    "content": "1. let\nBlock-scoped: It is only accessible inside the {} where it is declared.\n[code-snippet-0]\n\n2. const\nBlock-scoped: Same as let, it is restricted to the {} where it is declared.\n[code-snippet-1]\n\n3. var\nFunction-scoped: It is accessible throughout the function, even if declared inside a block (does not respect block scope).\n[code-snippet-2]\n\n4.** Key Difference in Hoisting**\n** 1. Variables declared with var are hoisted (moved to the top of the function or global scope) and initialized as undefined.**\n** 2. Variables declared with let and const are hoisted, but not initialized (accessing them before declaration causes an error).**",
    "codeSnippets": [
      "if (true) {\n  let x = 10;\n  console.log(x); // Output: 10\n}\nconsole.log(x); // Error: x is not defined\n",
      "if (true) {\n  const y = 20;\n  console.log(y); // Output: 20\n}\nconsole.log(y); // Error: y is not defined\n",
      "if (true) {\n  var z = 30;\n  console.log(z); // Output: 30\n}\nconsole.log(z); // Output: 30 (because `var` is not block-scoped)\n"
    ],
    "category": "JavaScript Basics",
    "topic": "let, const, var",
    "createdAt": "2024-12-31T14:58:40.184Z",
    "id": 1735657031320,
    "lastEdited": "2024-12-31T14:58:40.192Z"
  },
  {
    "title": "Coding Question on Scoping ",
    "content": "What will be the output of the following code?\nQuestion 1: Scope and Hoisting\n\n\n[code-snippet-0]\nQuestion 2: Block Scope with let and const\n\n\n[code-snippet-1]\n\nQuestion 3: Shadowing\n\n[code-snippet-2]\n\nQuestion 4: Re-declaration\n\n[code-snippet-3]\n\nQuestion 5: Temporal Dead Zone (TDZ)\n\n\n[code-snippet-4]\nQuestion 6: Nested Scopes\n\n\n[code-snippet-5]\n\nQuestion 7: Function Scope vs Block Scope\n\n[code-snippet-6]\n\nChallenge: Combine Concepts\nQuestion 8: Hoisting and Shadowing\n\n\n[code-snippet-7]\n\nQuestion 9: Re-declaration and Scope\n\n\n[code-snippet-8]\n\nWhat is the output of the following code?\n\n\n\n\n[code-snippet-9]\n\n[code-snippet-10]\n",
    "codeSnippets": [
      "function test() {\n  console.log(a); // ?\n  var a = 10;\n  console.log(a); // ?\n}\ntest();\n",
      "if (true) {\n  let x = 5;\n  const y = 10;\n  var z = 15;\n}\nconsole.log(z); // ?\nconsole.log(x); // ?\nconsole.log(y); // ?\n",
      "let a = 5;\n{\n  let a = 10;\n  console.log(a); // ?\n}\nconsole.log(a); // ?\n",
      "var b = 20;\nvar b = 30; // ?\n\nlet c = 40;\nlet c = 50; // ?\n\nconst d = 60;\nconst d = 70; // ?\n",
      "console.log(e); // ?\nlet e = 25;\n\nconsole.log(f); // ?\nconst f = 30;\n\nconsole.log(g); // ?\nvar g = 35;\n",
      "function outer() {\n  let x = 1;\n  var y = 2;\n  const z = 3;\n\n  function inner() {\n    console.log(x); // ?\n    console.log(y); // ?\n    console.log(z); // ?\n  }\n\n  inner();\n}\nouter();\nconsole.log(x); // ?\nconsole.log(y); // ?\nconsole.log(z); // ?\n",
      "function testVar() {\n  if (true) {\n    var a = 50;\n  }\n  console.log(a); // ?\n}\n\nfunction testLet() {\n  if (true) {\n    let b = 60;\n  }\n  console.log(b); // ?\n}\n\ntestVar();\ntestLet();\n",
      "var a = 1;\n\nfunction example() {\n  console.log(a); // ?\n  var a = 2;\n  console.log(a); // ?\n}\nexample();\nconsole.log(a); // ?\n",
      "let foo = 10;\n\nfunction bar() {\n  console.log(foo); // ?\n  var foo = 20;\n  console.log(foo); // ?\n}\n\nbar();\nconsole.log(foo); // ?\n",
      "function example() {\n  for (var i = 0; i < 3; i++) {\n    setTimeout(function() {\n      console.log(i);\n    }, 100);\n  }\n}\n\nexample();\n",
      "for (let i = 0; i < 3; i++) {\n  setTimeout(function() {\n    console.log(i);\n  }, 100);\n}\n"
    ],
    "category": "JavaScript Basics",
    "topic": "Scope",
    "createdAt": "2024-12-31T16:08:48.484Z",
    "id": 1735657438741,
    "lastEdited": "2024-12-31T16:08:48.489Z"
  },
  {
    "title": "What is the Temporal Dead Zone (TDZ) in JavaScript?",
    "content": "### NOTE:- The Temporal Dead Zone (TDZ) is a period where a variable exists but cannot be accessed yet.\n**Key Points:**\n** 1.When does it happen?**\n\n• It starts when the variable is declared with let or const but hasn't been initialized yet.\n• It ends when the code reaches the variable's declaration and initializes it.\n** 2. Why does it happen?**\n\n• JavaScript hoists variables to the top of their scope, but with let and const, they aren’t usable until the code explicitly initializes them.\n\n** 3. What happens if you try to access it in the TDZ?**\n• You'll get a ReferenceError.\n\n## Simple Example:\n[code-snippet-0]\n\n**Explanation:**\n• The variable a is declared with let, so it is hoisted but remains in the TDZ until it’s initialized at let a = 10;.\n• Trying to access a before this line gives an error.\n\n**TDZ with const:**\n[code-snippet-1]\n• const behaves like let, but you also can’t reassign it after initialization.\n\n**How is var Different?**\n• Variables declared with var are hoisted and initialized to undefined immediately, so they don’t have a TDZ.\n\n[code-snippet-2]\n\n### In Simple Words:\n** • Think of the TDZ as a \"waiting area\" for variables declared with let and const. They’re there, but you can’t use them until they’re officially initialized**.\n• **In the TDZ, let and const are not assigned any value, not even undefined**",
    "codeSnippets": [
      "console.log(a); //  Error: Cannot access 'a' before initialization\nlet a = 10;     // TDZ ends here\nconsole.log(a); //  Output: 10\n",
      "console.log(b); // ❌ Error: Cannot access 'b' before initialization\nconst b = 20;   // TDZ ends here\nconsole.log(b); // ✅ Output: 20\n",
      "console.log(c); // ✅ Output: undefined\nvar c = 30;     // Initialization\nconsole.log(c); // ✅ Output: 30\n"
    ],
    "category": "JavaScript Basics",
    "topic": "TDZ (Temporal Dead Zone)",
    "createdAt": "2024-12-31T15:46:22.286Z",
    "id": 1735659818110,
    "lastEdited": "2024-12-31T15:46:22.292Z"
  },
  {
    "title": "What happens if you use var to declare a variable in a for loop versus let? ",
    "content": "Note:-When you declare a variable inside a for loop with var or let, the behavior is different, especially regarding scoping.\n\n**1. Using var inside a for Loop**\n• Function-scoped: The variable declared with var is scoped to the entire function (or global scope if not inside a function).\n**• Even if the variable is declared inside the loop, it is accessible outside the loop (because of function/global scope).**\n\n[code-snippet-0]\n\n**2. Using let inside a for Loop**\n• Block-scoped: The variable declared with let is scoped only to the current iteration of the loop.\n•** Each iteration gets its own separate instance of the variable.**\n[code-snippet-1]\n\n### Why the Difference Matters:\n**With var:**\n• The loop variable is shared across all iterations, so if you use var to declare the variable, it keeps the same reference across the whole function (or global scope). This can cause unexpected behavior, especially when dealing with asynchronous operations.\n\n**With let:**\n• Each iteration of the loop has a separate block-scoped variable, which prevents issues where the loop variable gets overwritten by other iterations or asynchronous functions.\n",
    "codeSnippets": [
      "for (var i = 0; i < 3; i++) {\n  console.log(i); // Output: 0, 1, 2\n}\n\nconsole.log(i); // Output: 3 (Accessible outside the loop)\n",
      "for (let i = 0; i < 3; i++) {\n  console.log(i); // Output: 0, 1, 2\n}\n\nconsole.log(i); // Error: i is not defined (Cannot access i outside the loop)\n"
    ],
    "category": "JavaScript Basics",
    "topic": "Scope",
    "createdAt": "2024-12-31T16:00:33.982Z",
    "id": 1735660699772,
    "lastEdited": "2024-12-31T16:00:33.987Z"
  },
  {
    "title": "Difference Between Function-scoped and Block-scoped Variables",
    "content": "**In JavaScript, the scope of a variable determines where it can be accessed. Function-scoped and Block-scoped refer to how variables are scoped and where they can be used in the code.**\n\n**1. Function-scoped Variables (var)**\n• A function-scoped variable is only accessible within the function where it was declared.\n• If you declare a variable using var, it is scoped to the entire function, even if it's declared inside a block (like an if or for loop).\n• This means the variable is accessible outside the block but still within the function.\n[code-snippet-0]\n**2. Block-scoped Variables (let and const)**\n• A block-scoped variable is only accessible within the block (denoted by {}) where it was declared.\n• let and const are block-scoped, meaning if you declare them inside a loop, if statement, or any block, they can only be used within that block.\n\n[code-snippet-1]\n",
    "codeSnippets": [
      "function test() {\n  if (true) {\n    var x = 10;  // Function-scoped\n  }\n  console.log(x);  // Output: 10 (x is accessible outside the block but inside the function)\n}\n\ntest();\n",
      "function test() {\n  if (true) {\n    let y = 20;  // Block-scoped\n    const z = 30;  // Block-scoped\n    console.log(y);  // Output: 20\n    console.log(z);  // Output: 30\n  }\n  console.log(y);  // Error: y is not defined\n  console.log(z);  // Error: z is not defined\n}\n\ntest();\n"
    ],
    "category": "JavaScript Basics",
    "topic": "Scope",
    "createdAt": "2024-12-31T16:06:48.855Z",
    "id": 1735661208855
  },
  {
    "title": "What is Scoping in JavaScript?",
    "content": "**Scoping refers to the visibility or accessibility of variables in different parts of your code. It determines where in your code a variable can be used and where it cannot.**\n**Two Main Types of Scopes in JavaScript:**\n**1.Global Scope**\n\n• A variable declared in the global scope is accessible everywhere in your code.\n• It is declared outside of any function or block.\n[code-snippet-0]\n\n**2. Local Scope**\n• Variables declared inside a function or block (like an if statement or loop) are locally scoped.\n• They can only be accessed inside that function or block.\n\n### Types of Local Scopes:\n**1. Function Scope (with var)**\n\n• If a variable is declared using var, it is function-scoped. This means the variable is accessible anywhere inside the entire function.\n\n[code-snippet-1]\n\n** 2. Block Scope (with let and const)**\n\n• If a variable is declared using let or const, it is block-scoped. This means the variable is only accessible inside the block (such as within a for loop or an if statement).\n\n[code-snippet-2]\n",
    "codeSnippets": [
      "let a = 10;  // Global scope\n\nfunction test() {\n  console.log(a);  // We can access 'a' here because it's global\n}\n\ntest();  // Output: 10\nconsole.log(a);  // Output: 10\n",
      "function test() {\n  var x = 5;  // Function-scoped\n  console.log(x);  // Output: 5\n}\n\ntest();\nconsole.log(x);  // Error: x is not defined (x can't be accessed outside the function)\n",
      "if (true) {\n  let y = 10;  // Block-scoped\n  console.log(y);  // Output: 10\n}\n\nconsole.log(y);  // Error: y is not defined (y can't be accessed outside the block)\n"
    ],
    "category": "JavaScript Basics",
    "topic": "Scope",
    "createdAt": "2024-12-31T16:41:34.651Z",
    "id": 1735661805675,
    "lastEdited": "2024-12-31T16:41:34.663Z"
  },
  {
    "title": " What is Lexical Scope ?",
    "content": "**Lexical scope simply means that a function can access the variables that were available where the function was written, not where it's called.**\n\n**In other words:**\n\n• If you define a function inside another function, the inner function remembers the variables from the outer function, even if it is called later.\n**Think of it like this:**\n• The location where the function is written (in the code) determines what variables the function can access.\n### Simple Example:\n\n[code-snippet-0]\n\n**Here:**\n\n• The inner function is inside the outer function, so it can access message because of lexical scope.\n• Even though inner is called inside outer, it remembers message because of where it was written.\n**Key Points of Lexical Scope:**\n**• Functions can access variables that are in their surrounding (outer) environment, which is called lexical scoping.**\n• It is based on where the function is defined, not where it is called.\n\n\n### Another Example (Closure):\n\n\n[code-snippet-1]\n\n**Here:**\n\n• The function increment has access to count even though createCounter has already finished executing.\n• Each call to createCounter remembers its own count variable, creating separate counters because of lexical scope.\n",
    "codeSnippets": [
      "function outer() {\n  let message = \"Hello from outer\";  // Outer function's variable\n\n  function inner() {\n    console.log(message);  // Inner function can access 'message' from outer\n  }\n\n  inner();\n}\n\nouter();  // Output: \"Hello from outer\"\n",
      "function createCounter() {\n  let count = 0;\n\n  return function increment() {\n    count++;  // This function can access 'count' because of lexical scope\n    console.log(count);\n  };\n}\n\nconst counter1 = createCounter();\nconst counter2 = createCounter();\n\ncounter1();  // Output: 1\ncounter1();  // Output: 2\ncounter2();  // Output: 1 (counter2 has its own 'count' variable)\n"
    ],
    "category": "JavaScript Basics",
    "topic": "Scope",
    "createdAt": "2024-12-31T17:03:13.980Z",
    "id": 1735664529821,
    "lastEdited": "2024-12-31T17:03:13.986Z"
  }
]